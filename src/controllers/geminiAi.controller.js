import mongoose, { isValidObjectId } from "mongoose";
import { Post } from "../models/post.model.js";
import { ApiError } from "../utils/ApiError.js";
import { ApiResponse } from "../utils/ApiResponse.js";
import { asyncHandler } from "../utils/asyncHandler.js";
import { chatModel, ImageModel, textModel } from "../utils/geminiAi.js";
import { response } from "express";
import { User } from "../models/users.model.js";
import { Like } from "../models/like.model.js";

const getCommentsSuggestion = asyncHandler(async (req, res) => {
  const { postId } = req.params;
  const { attachment } = req.body;
  console.log(attachment)
  if (!isValidObjectId(postId)) {
    throw new ApiError(400, "postId is invalid")
  }
  const post = await Post.aggregate([
    {
      $match: { _id: new mongoose.Types.ObjectId(postId) }
    },
    {
      $lookup: {
        from: "users",
        localField: "user",
        foreignField: "_id",
        as: "user",
        pipeline: [
          {
            $project: {
              _id: 1,
              username: 1,
              avatar: 1,
            }
          }
        ]
      }
    },
    {
      $addFields: {
        "user": { $first: "$user" }
      }
    },
    {
      $lookup: {
        from: "likes",
        localField: "_id",
        foreignField: "likePost",
        as: "likes"
      }
    },
    {
      $lookup: {
        from: "comments",
        localField: "_id",
        foreignField: "post",
        as: "comments",
        pipeline: [
          {
            $lookup: {
              from: "users",
              localField: "user",
              foreignField: "_id",
              as: "user",
              pipeline: [
                {
                  $project: {
                    username: 1,
                    avatar: 1
                  }
                }
              ]
            }
          },
          {
            $addFields: {
              "user": { $first: "$user" }
            }
          }
        ]
      }
    },
    {
      $addFields: {
        likesCount: { $size: "$likes" },
        commentsCount: { $size: "$comments" },
        isLiked: {
          $cond: {
            if: { $in: [req.user._id, "$likes.LikedBy"] },
            then: true,
            else: false
          }
        }
      }
    },
    {
      $sort: {
        updatedAt: -1
      }
    }
  ]);


  if (!post) {
    throw new ApiError(404, "post not found.")
  }
  const prompt = ` Here are the details of a recent ${post}:

    - **Content:** ${post[0].content}
    - **tags:** ${post[0].tags}
    - **Number of Likes:** ${post[0].likesCount}
    - **Number of Comments:** ${post[0].commentsCount}
    - **Current User Liked:** ${post[0].isLiked}

    The author of the post is ${post[0].user.username}. 

    Based on this information, suggest 2-3 engaging comments that could encourage more interaction with the post. Consider expressing interest, asking questions, or adding thoughtful insights.
    give 3 comments that is classic comment , fun comment,interesting comment each should has the emojies`
  const imageParts = `${post[0].attachment.url}`
  if (attachment.resource_type === "image") {
    const response = await ImageModel(prompt, imageParts);
    if (!response) {
      throw new ApiError(500, "server error while generating prompts.")
    }
    return res.status(200).json(new ApiResponse(200, response, " Prompt Successfully Generated by imagemodel"))

  } else {
    const response = await textModel(prompt);
    if (!response) {
      throw new ApiError(500, "server error while generating prompts")
    }
    return res.status(200).json(new ApiResponse(200, response, "Prompt Successfully Generated by text-model"))
  }

})

const getReplyOFComment = asyncHandler(async (req, res) => {
  const { postId } = req.params;
  const commentID = "669fbb98e8bc52a0fb67f8cd";
  if (!isValidObjectId(postId)) {
    throw new ApiError(400, "postId is invalid")
  } const post = await Post.aggregate([
    {
      $match: { _id: new mongoose.Types.ObjectId(postId) }
    },
    {
      $lookup: {
        from: "users",
        localField: "user",
        foreignField: "_id",
        as: "user",
        pipeline: [
          {
            $project: {
              _id: 1,
              username: 1,
              avatar: 1,
            }
          }
        ]
      }
    },
    {
      $addFields: {
        "user": { $first: "$user" }
      }
    },
    {
      $lookup: {
        from: "likes",
        localField: "_id",
        foreignField: "likePost",
        as: "likes"
      }
    },
    {
      $lookup: {
        from: "comments",
        localField: "_id",
        foreignField: "post",
        as: "comments",
        pipeline: [
          {
            $lookup: {
              from: "users",
              localField: "user",
              foreignField: "_id",
              as: "user",
              pipeline: [
                {
                  $project: {
                    username: 1,
                    avatar: 1
                  }
                }
              ]
            }
          },
          {
            $addFields: {
              "user": { $first: "$user" }
            }
          },
          {
            $match: {
              _id: new mongoose.Types.ObjectId(commentID)  // Filter comments by commentID
            }
          }
        ]
      }
    },
    {
      $addFields: {
        likesCount: { $size: "$likes" },
        commentsCount: { $size: "$comments" },
        isLiked: {
          $cond: {
            if: { $in: [req.user._id, "$likes.LikedBy"] },
            then: true,
            else: false
          }
        }
      }
    },
    {
      $sort: {
        updatedAt: -1
      }
    }
  ]);


  if (!post) {
    throw new ApiError(404, "post not found.")
  }
  const prompt = `Based on the following post and comment, generate a thoughtful reply from a user.


  **Post Details:**
  
    - **Content:** ${post[0].content}
    - **tags:** ${post[0].tags}
    - **Number of Likes:** ${post[0].likesCount}
    - **Number of Comments:** ${post[0].commentsCount}
    - **Current User Liked:** ${post[0].isLiked}

    The author of the post is ${post[0].user.username}, who has an avatar [Avatar].

  **Comment Details:**
  - **Comment Content:** ${post[0].comments[0].content}
  - **Commenter Username:** ${post[0].comments[0].user.username}

  **Comment to Reply To the content of comment id given above ** 

  Please generate a reply to the comment  that is engaging and provides relevant information if applicable.
  use great 2-3 emojies. 
  `

  const response = await textModel(prompt);
  if (!response) {
    throw new ApiError(500, "server error while generating prompts.")
  }
  return res.status(200).json(new ApiResponse(200, response, " Prompt Successfully Generated "))

})

const getUserProfileSummery = asyncHandler(async (req, res) => {
  const { userId } = req.params;
  const posts = await Post.aggregate([{ $match: { user: new mongoose.Types.ObjectId(userId) } }, {
    $lookup: {
      from: "likes",
      localField: "_id",
      foreignField: "likePost",
      as: "likes"
    }
  },
  {
    $lookup: {
      from: "comments",
      localField: "_id",
      foreignField: "post",
      as: "comments"
    }
  },
  {
    $addFields: {
      likesCount: { $size: "$likes" },
      commentsCount: { $size: "$comments" },
      isLiked: {
        $cond: {
          if: { $in: [req.user._id, "$likes.LikedBy"] },
          then: true,
          else: false
        }
      }
    }
  },
  { $sort: { updatedAt: -1 } }]);
  console.log("posts", posts)


  const user = await User.findById(userId).select("-refreshToken -password")
  console.log("user", user)


  const allLikedPost = await Like.aggregate([{
    $match: {
      LikedBy: new mongoose.Types.ObjectId(userId)
    }
  }, {
    $lookup: {
      from: "posts",
      localField: "likePost",
      foreignField: "_id",
      as: "post",
      pipeline: [{
        $lookup: {
          from: "users",
          localField: "user",
          foreignField: "_id",
          as: "user",
          pipeline: [{
            $project: {
              username: 1,
            }
          }]
        }
      }, {
        $addFields: {
          user: {
            $first: "$user"
          }
        }
      }, {
        $lookup: {
          from: "likes",
          localField: "_id",
          foreignField: "likePost",
          as: "likes"
        }
      },
      {
        $lookup: {
          from: "comments",
          localField: "_id",
          foreignField: "post",
          as: "comments"
        }
      },
      {
        $addFields: {
          likes: { $size: "$likes" },
          comments: { $size: "$comments" },
        }
      }]
      ,
    }
  }, {
    $addFields: {
      post: { $first: "$post" }
    }
  }])

  console.log("allLikedPost", allLikedPost)

  const prompt = `here is the detail of user=${user} and its uploaded posts=${posts} since now and also user's liked post=${allLikedPost}
Summarize the user profile and their activities based on the given data:

User Profile: Provide a detailed summary of the user's profile information, including their username, full name, avatar, address, mobile number, email, bio, and the dates when their account was created and last updated.

Post Feed: Analyze the user's post feed to determine:

The content of their posts (if any).
The frequency of their posts.
The engagement on their posts (likes and comments).
Liked Posts: Summarize the liked posts including:

The content of the posts.
The tags associated with these posts.
The number of likes and comments on these posts.
Identify which posts are most engaging or popular based on likes and comments.
Engagement and Interests:

Determine the userâ€™s most engaged content by evaluating the number of likes and comments on their posts.
Identify the user's interests based on the content and tags of the posts they have liked.
Provide insights into the topics or themes that appear to be of most interest to the user.
Overall Analysis:

Summarize the user's overall activity and interests.
Highlight any significant trends or patterns in their engagement and preferences.
 **note:motive is to get summery that is help other user to get what's the perticular user's profile is about and make more connective people. here if anything is confusing just live it and give summery ahead and don't give sensitive information about mobile and email and avatar etc.**


 Please generate a summery of the user profile. 
 use great 2-3 emojies for user to not to get bored during reading summery. 
 
`


  const response = await textModel(prompt);
  if (!response) {
    throw new ApiError(500, "server error while generating prompts")
  }
  return res.status(200).json(new ApiResponse(200, response, "Prompt Successfully Generated by text-model"))


})

const getTodaysTrendSummery = asyncHandler(async (req, res) => {
  const { page = 1, limit = 10 } = req.query;
  const tags = Post.aggregate([
    {
      $addFields: {
        characters: { $split: ["$tags", " "] } // Split tags into individual characters
      }
    },
    {
      $unwind: "$characters" // Unwind the array to have one document per character
    },
    {
      $match: {
        characters: { $ne: "" },
        // Exclude empty characters if any
      }
    },
    {
      $group: {
        _id: "$characters", // Group by character
        count: {
          $sum: 1
        } // Count occurrences

      }
    }, {
      $sort: { count: -1 }
    }])
  const options = {
    page: parseInt(page, 10),
    limit: parseInt(limit, 10),
    customLable: {
      totalDocs: "total tags",
      docs: "tags"
    }
  }

  const response = await Post.aggregatePaginate(tags, options)
  console.log(response)
  const prompts = `here is the trending topics in the social media app called City Connect ${response.docs} in this array the _id is the topic name and the count is the number of post happened since tommorow on given topic city connect is a new social media platform thats why there is very low posting happened here now give user the todays trend detail and whats happend when user are not at here make interesting article type texts and also add emogies. dont give like _id and [object object ] like response the user cant under stand anything if you send the same as coder.`

  const text = await textModel(prompts);
  return res.status(200).json(new ApiResponse(200, text, "prompt generated successfully"))
})

const getPostssummery = asyncHandler(async (req, res) => {
  const { postID } = req.params;
  if (!isValidObjectId(postID)) {
    throw new ApiError(400, "invalid postId.")

  }
  const post = await Post.aggregate([{
    $match: {
      _id: new mongoose.Types.ObjectId(postID)
    }
  }, {
    $lookup: {
      from: "users",
      localField: "user",
      foreignField: "_id",
      as: "user",
      pipeline: [
        {
          $project: {
            _id: 1,
            username: 1,
            avatar: 1
          }
        }
      ]
    }
  }, {
    $addFields: { user: { $first: "$user" } }
  }, {
    $lookup: {
      from: "likes",
      localField: "_id",
      foreignField: "likePost",
      as: "likes"
    }
  },
  {
    $lookup: {
      from: "comments",
      localField: "_id",
      foreignField: "post",
      as: "comments",
      pipeline: [
        {
          $lookup: {
            from: "users",
            localField: "user",
            foreignField: "_id",
            as: "user",
            pipeline: [
              {
                $project: {
                  username: 1,
                  avatar: 1
                }
              }
            ]
          }
        },
        {
          $addFields: {
            "user": { $first: "$user" }
          }
        }
      ]
    }
  },
  {
    $addFields: {
      likesCount: { $size: "$likes" },
      commentsCount: { $size: "$comments" },
      isLiked: {
        $cond: {
          if: { $in: [req.user._id, "$likes.LikedBy"] },
          then: true,
          else: false
        }
      }
    }
  }])

  if (!post) {
    throw new ApiError(500, "server error while fetching post data.")
  }
  const prompt = `Based on the following post and comment, generate a thoughtful reply from a user.


  **Post Details:**
  
    - **Content:** ${post[0].content}
    - **tags:** ${post[0].tags}
    - **Number of Likes:** ${post[0].likesCount}
    - **Number of Comments:** ${post[0].commentsCount}
    - **Current User Liked:** ${post[0].isLiked}

    The author of the post is ${post[0].user.username}, who has an avatar [Avatar].

  **Comment Details:**
  - **Comment Content:** ${post[0].comments[0].content}
  - **Commenter Username:** ${post[0].comments[0].user.username}

  **make summery of the post and the concept of what user want to give detail about in post and also his target audiance.so that the user who just come to see post get proper post's detail **
 **note:motive is to get summery that is help user to get what's post is about **

  Please generate a summery to the post 
  use great 2-3 emojies for user to not to get bored during reading content. 
  `
  const imageParts = `${post[0].attachment.url}`
  if (post[0].attachment.resource_type === "image") {
    const response = await ImageModel(prompt, imageParts);
    if (!response) {
      throw new ApiError(500, "server error while generating prompts.")
    }
    return res.status(200).json(new ApiResponse(200, response, " Prompt Successfully Generated by imagemodel"))

  } else {
    const response = await textModel(prompt);
    if (!response) {
      throw new ApiError(500, "server error while generating prompts")
    }
    return res.status(200).json(new ApiResponse(200, response, "Prompt Successfully Generated by text-model"))
  }

})

const startChatting = asyncHandler(async (req, res) => {
  const { text } = req.body;

  const response = await textModel(text)
  return res.status(200).json(new ApiResponse(200, response, "chating successfully generated."))

})




export {
  getCommentsSuggestion,
  getReplyOFComment,
  getPostssummery,
  getUserProfileSummery, getTodaysTrendSummery,
  startChatting
}
